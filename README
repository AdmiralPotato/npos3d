NPOS3D: Nuclear Pixel Old School 3D
Vector 3D game engine written in Javascript and HTML5's 2D Canvas context

----
DISCLAIMER:
In many ways, this project is a lot of 'firsts' for me.
	My first version controlled project
	My first package based project, and by packages, I think I mean 'one type of object per file'
	My first project where I've shared the source with others, asking for help in code review and help in understanding maths and realtime performance concepts.

I understand that I have a long way to go, and much to learn. I know that within this implementation of a set of ideas, there may be bugs and there may be brilliant tricks, but without this practice, I will not improve. Please be aware that while this project is a learning attempt, I also plan on using it in production for a few different toys and games. Other than learning, a number of its goals and objectives may change, as my needs of the engine change. If you end up using any of this code in any of your projects, I would love to see how! Please share your thoughts and feedback with me, and I will do my best to address them as I can find the time.
-Admiral
----

There are a few basic premises that this engine is designed to work with at the moment:

	1: There is typically only a single canvas 2D context for all objects to be rendered on. This allows for the correct rendering of perspective and sub-pixel precision on the antialiasing for each object. This canvas and context is assumed to take 100% width and height of the containing window. Each frame, the size of the canvas is checked against the size of the canvas from last frame. If the window size has changed, the canvas is resized, the context is resized, and all variables dependent on the size of the canvas are updated before anything else is allowed to happen that frame.

	2: There is a primary update loop that (tries) to run once every 60th of a second. The primary update loop has 3 main responsibilities:

		* Handle global interframe compositing operations, eg. clearing the context background to transparency every frame or fading the background of one frame behind the next to give a frame blurring effect

		* Performing any transformations on the 2D context to center it on the canvas, (so that 0,0 on the context is always the center of the canvas - negative y is up, negative x is left) then reset those transformations just before the end of the update function

		* There is a 'global render queue', an array of all objects that need to be updated each frame. This array is looped through, and the update method on each object is executed. This requires that each object in this array MUST have an update() method. Each object is responsible for performing the functions needed to display itself on screen when that update method is executed.

	3: Since many of the objects in a scene have many of the same types of mandatory properties, rather than relying too heavily on a confusing inheritance chain or wasting much time of re-defining many of the parameters on each unique type's constructor method, I have found it more useful to create an almost empty object, and then pass that object into a standalone 'blessing' function which will imbue it with a series of properties(pos, rot, scale, etc), negating a lot of confusion with inheritance structures.

	4: Each 3D object has a basic set of properties that it depends on to function properly.
		pos: 3 key array- Default value is [0,0,0] - The position of the object in 3D space.
		rot: 3 key array- Default value is [0,0,0] - The rotation of the object in radians, using its internal 0,0,0 point as the center of that rotation operation. 
		scale: 3 key array- Default value is [1,1,1] - The scale of the object using its internal 0,0,0 point as the center of that scale operation.
		shape: A mesh object composed of these properties:
			color: Any valid CSS color value, used for the rendering of each line in this mesh that does not specify its own color.
			points: An array of 3 key arrays, representing the positions of all vertexes in the mesh
			lines: An array of 2(or 3) key arrays, the first two values of each array representing the array keys of each of the two points above that should be used to draw a line on screen. If a line array possesses a third key, that is the CSS color value that will be used when drawing the line.
		transformedPointCache: Generated at runtime, it is a cached array of all of the points from the mesh property of the object's assigned shape, with the rotation and scale of the object applied to them. This property is updated each frame that the rotation and scale properties on an object have changed since the last frame.
		boundingBox: Generated at runtime each time the transformedPointCache is updated, it is an array of 2 keys, each a 3 key array representing the two minimum and maximum point pairs used to define a cubic bounding box.

	5: Each frame as the update() method of each object is executed, certain functions check its current scale and rotation against those values from the previous frame and if either has changed, regenerate a cached array of those transformed points. The object's mesh is then assigned a cubic bounding box based on the transformedPointCache

Here are some variable naming standards that have been used in this project for internal consistency. Certain variables are used in many places, and for programmer convenience, have been heavily abbreviated. The following list is not exhaustive, but may become such over time.

pi = Math.PI
tau = pi * 2
deg = tau / 360
w = the width of the canvas in pixels
h = the height of the canvas in pixels
cx = half of the width of the canvas, rounded to the nearest integer value
cy = ditto, but for height
c = The primary global canvas 2D context
q = The primary global render queue
